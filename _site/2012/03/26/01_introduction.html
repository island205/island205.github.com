<!doctype html>
<!--[if lt IE 7]> <html class="no-js lt-ie9 lt-ie8 lt-ie7" lang="en"> <![endif]-->
<!--[if IE 7]>    <html class="no-js lt-ie9 lt-ie8" lang="en"> <![endif]-->
<!--[if IE 8]>    <html class="no-js lt-ie9" lang="en"> <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"> <!--<![endif]-->
<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">

	<title></title>
	<meta name="description" content="">
	<meta name="author" content="">

	<meta name="viewport" content="width=device-width">

	<link rel="stylesheet" href="/css/style.css">
	<link rel="stylesheet" href="/css/highlight.css">
	<link rel="stylesheet" href="/css/custom.css">
	<link rel="stylesheet" media="screen" href="/css/screen.css">

	<script src="/js/libs/modernizr-2.5.3.min.js"></script>
</head>
<body class="gray">
<header>
</header>
<div role="main" id="main">
	<div class="post">
	<div class='back'><a href='/tlboc/'>&laquo; 返回目录</a></div>
<h1 id='coffeescirpt'>CoffeeScirpt是什么？</h1>

<p><a href='http://coffeescript.org'>CoffeeScript</a>是一门小巧的语言，会编译为JavaScript。它的语法风格受到了Ruby和Python影响，很多特性都借鉴于这两种语言。我们写作本书的目的在于帮助你学习CoffeeScript，明白最佳实践是什么，以及帮助你开始创建有意思的客户端程序。这本书很小，仅仅只有五章，但是对与CoffeeScript这门小语言来说已足够。</p>

<p>这本书是完全开源的，作者是<a href='http://alexmaccaw.co.uk'>Alex MacCaw</a> (或者 <a href='http://twitter.com/maccman'>@maccman</a>)，<a href='https://github.com/dxgriffiths'>David Griffiths</a>、<a href='http://github.com/satyr'>Satoshi Murakami</a>和 <a href='https://github.com/jashkenas'>Jeremy Ashkenas</a>也做了不小的贡献。</p>

<p>如果你有任何勘误和建议，千万别吝啬到本书的<a href='https://github.com/arcturo/library'>GitHub page</a>发个ticket。或许你们还对我的另外一本书<a href='http://oreilly.com/catalog/9781449307530/'>JavaScript Web Applications by O&#8217;Reilly</a>感兴趣，我在该书中对富JavaScript应用以及如何把状态转移到客户端进行了探索。</p>

<p>好了，开始我们的CoffeeScript探索之旅吧。为什么CoffeeScript要比原生的JavaScript好？首先，能够少写代码——CoffeeScript非常简洁，充分地利用空格。以我的经验来看，比起纯JavaScript的话，它能减少三分之一到一半的代码量。还有，CoffeeScript开有一些优雅的特性，比方说列表解析、原型符号别名和类等等，能够有效的减少需要你的输入。</p>

<p>更重要的是，JavaScript有很多不为人知的 <a href='http://bonsaiden.github.com/JavaScript-Garden/'>秘密</a>，这些秘密往往让无经验的开发者摔跤。CoffeeScript有原则地选择了一些JavaScript的特性，巧妙地避开了这些不足，解决了该语言的怪癖。</p>

<p>CoffeeScript<em>不是</em>JavaScript的超集，因此尽管你可以在CoffeeScript中的使用外部的JavaScript类库，但是如果你在没有转化之前而直接编译当前的JavaScript的话，会出现语法错误。编译器会把CoffeeScript代码转化为相对应的JavaScript，这样在运行时就不需要解释了。</p>

<p>首先澄清一些误解。由于处理运行时错误需要JavaScript相关的知识，要写CoffeeScript就得了解JavaScript。但是话说回来，运行时错误通常比较明显，并且到目前位置，我没觉得从JavaScript映射到CoffeeScript会有什么问题。第二个问题是我经常听到CoffeeScript相关的话题是速度。即，CoffScript编译后的JavaScript运行起来相比与之等价的纯JavaScript代码要慢。但实际情况证明并不是问题。CoffeeScript看起来与徒手写的JavaScript代码运行速度相当，甚至更快。</p>

<p>CoffeeScript的劣势是什么？是的，在你和JavaScript之间介多了编译这一步。CoffeeScript也在尝试尽力通过产生优雅的可读性强的JavaScript，以及在服务器端集成自动编译来弥补这个问题。另外一个缺陷是，作为一个新的语言，事实上现阶段社区也还比较小，想找个懂这门语言的合伙人会花费你的大量你的时间。当然，CoffeeScript发展迅猛，相关的IRC列表也是人才济济，如果你有什么问题的话，都会得到迅速的解答。</p>

<p>CoffeeScript的用途并不仅限于浏览器，把它用在JavaScript实现的服务端也非常不错，比方说在 <a href='http://nodejs.org/'>Node.js</a>上。还有，CoffeeScript越来越广泛，有更多的集成，比方说它已经是Rails3.1的标配。现在正是进入CoffeeScript学习的时机。你现在为学习这门语言付出的时间在以后会以为你节约大量的时间作为回报的。</p>

<h2 id='id43'>初始化安装</h2>

<p>一种尝试这个类库最简单的方式就是直接在浏览器中使用它，访问<a href='http://coffeescript.org'>http://coffeescript.org</a>，点击<em>Try CoffeeScript</em>标签。这个网站使用浏览器版的CoffeeScript编译器，把在左边面板任意输入的CoffeeScript代码编译为JavaScriprt后显示在右边的面板中。</p>

<p>你也可以使用<a href='http://js2coffee.org/'>js2coffee</a>项目把JavaScript转变为CoffeeScirpt。这在把JavaScript项目迁移到CoffeeScript上时尤其有用。</p>

<p>实际上，你自己都可以使用基于浏览器的CoffeeScirpt编译器，只需要在页面中包含<a href='http://jashkenas.github.com/coffee-script/extras/coffee-script.js'>这个脚本</a>，使用正确类型（type）的标标签记CoffeeScript脚本即可。</p>
<div class='highlight'><pre><code class='html'>    <span class='nt'>&lt;script </span><span class='na'>src=</span><span class='s'>&quot;http://jashkenas.github.com/coffee-script/extras/coffee-script.js&quot;</span> <span class='na'>type=</span><span class='s'>&quot;text/javascript&quot;</span> <span class='na'>charset=</span><span class='s'>&quot;utf-8&quot;</span><span class='nt'>&gt;&lt;/script&gt;</span>
    <span class='nt'>&lt;script </span><span class='na'>type=</span><span class='s'>&quot;text/coffeescript&quot;</span><span class='nt'>&gt;</span>
      <span class='err'>#</span> <span class='nx'>Some</span> <span class='nx'>CoffeeScript</span>
    <span class='nt'>&lt;/script&gt;</span>
</code></pre>
</div>
<p>显然，在生产环境中，由于会减慢客户端的运行，所以没人愿意在运行时解释执行CoffeeScript。作为替代，CoffeeScript提供了一个<a href='http://nodejs.org'>Node.js</a>版的编译器来对CoffeeScript文件进行预处理。</p>

<p>要安装该编译器，首先必须保证你已经有了稳定可用的<a href='http://nodejs.org/'>Node.js</a>和<a href='http://npmjs.org/'>npm</a>（Node程序包管理工具）。然后你就可以使用npm来安装CoffeeScirpt了：</p>
<div class='highlight'><pre><code class='bash'>    npm install -g coffee-script
</code></pre>
</div>
<p>这同时还为你提供了一个<code>coffee</code>的可执行二进制程序，如果不用任何命令行参数而直接运行该程序，它会给你一个CoffeeScript的命令行，这个命令行你可以用来快速的运行一些CoffeeScript语句。要预处理文件的话，使用<code>--compile</code>参数：</p>
<div class='highlight'><pre><code class='bash'>    coffee --compile my-script.coffee
</code></pre>
</div>
<p>如果没有指定<code>--output</code>参数，CoffeeScript会直接将编译后的代码写入到一个同名的JavaScript文件中，本例中就是<code>my-script.js</code>。已存在该文件的话会被复写掉，因此要当心你的JavaScript文件被覆盖。使用<code>--help</code>参数可以看到一个完整的可用命令行参数列表。</p>

<p>就如你在之前看到的一样，CoffeeScript文件的默认扩展名是<code>.coffee</code>，除去其他原因之外，能让像<a href='http://macromates.com/'>TextMate</a>这样的编译器能够辨认出文件中包含的是什么语言的代码从而是用相对应的高亮也是其中之一。TextMate并不包含对CoffeeScript的支持，但是你可以安装这个<a href='https://github.com/jashkenas/coffee-script-tmbundle'>包</a>来提供支持。</p>

<p>编译看起来既不方便又很无聊。没办法，它就是这样。我们将会学习通过自动编译的方法来解决这个问题，不过首先我们先学习一下这门语言的语法。</p>
<div>

</div>
<footer>
</footer>

<script src="//ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
<script>window.jQuery || document.write('<script src="js/libs/jquery-1.7.1.min.js"><\/script>')</script>

<!-- scripts concatenated and minified via ant build script-->
<script src="/js/plugins.js"></script>
<script src="/js/script.js"></script>
<!-- end scripts-->

<script>
	var _gaq=[['_setAccount','UA-XXXXX-X'],['_trackPageview']];
	(function(d,t){var g=d.createElement(t),s=d.getElementsByTagName(t)[0];
	g.src=('https:'==location.protocol?'//ssl':'//www')+'.google-analytics.com/ga.js';
	s.parentNode.insertBefore(g,s)}(document,'script'));
</script>

</body>
</html>
